
## 进程、线程和协程之间的区别

进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是CPU调度和分派的 基本单位，是比程序更小的能独立运行的基本单位，同一个进程中多个线程之间可以并发执行。

## 守护线程

在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 
用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；
只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是
GC (垃圾回收器)，它就是一个很称职的守护者。User和Daemon两者几乎没有
区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出
运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守
护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。

参考：http://blog.csdn.net/shimiso/article/details/8964414

## 创建线程

* 继承Thread类
* 实现Runnable接口

更多的是使用Runanble接口，因为Java不支持多继承，而且继承整个Thread类的开销过大。

## 线程阻塞

方法|说明
--|--
sleep()|
suspend()和resume()|
yield()|
wait()和notify()|

待完善，白话JAVA虚拟机

## 线程局部变量

ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。
ThreadLocal为每个线程的中并发访问的数据提供一个副本，通过访问副
本来运行业务，这样的结果是耗费了内存，单大大减少了线程同步所带来
性能消耗，也减少了线程并发控制的复杂度。
 
ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的
使用比synchronized要简单得多。
 
ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal
与synchronized有本质的区别。synchronized是利用锁的机制，使变量
或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程
都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对
象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相
反，它用于在多个线程间通信时能够获得数据共享。
 
Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。
 
当然ThreadLocal并不能替代synchronized,它们处理不同的问题域。
Synchronized用于实现同步机制，比ThreadLocal更加复杂。

## 线程安全相关

http://www.tuicool.com/articles/zuui6z

## 乐观锁 & 悲观锁

* 乐观锁  
增加一个版本号标记，当进行数据修改的时候，首先验证版本号是否
被修改，如果没有被修改则进行数据更新，如果已经更改，则说明其
他线程已经进行了更改，更新失败，之后采取对应的策略进行后续的
处理，比如再次进行数据的更新请求等。优点是防止并发导致的数据
错误，但是在并发量大的时候，因为重复请求，会增加服务器的负担。

使用场景：java cas ,redis watch ，数据库记录修改加版本号等

* 悲观锁  
当有请求过来，就

## 死锁 & 活锁

* 死锁  
是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于
彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法
推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远
在互相等待的进程称为死锁进程。

* 活锁  
活锁指的是任务或者执行者没有被阻塞，
由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。
活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，
导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，
处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁
的实体表现为等待；活锁有可能自行解开，死锁则不能。









