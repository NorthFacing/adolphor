---
layout:     post
title:      设计模式之 —— 观察者模式进阶：监听器模式
date:       2020-03-14 21:23:26 +0800
postId:     2020-03-14-21-23-26
categories: [设计模式]
tags:       [设计模式]
geneMenu:   true
excerpt:    设计模式之 —— 监听器模式
---

监听器模式并不是一个新的设计模式，而是观察者模式在特定场景下的一种改造和应用。观察者模式中，`主题` 会在特定逻辑下通知所有 `观察者`。 如果这个通知不包含任何信息，那么这种实现就是通常的观察者模式。如果 `主题` 通知 `观察者` 的过程带有一些 <其他信息>。那么 `主题` 本身已经上升成为了 `事件源`， 而通知中带有的 <其他信息> 经过封装就成为了事件。事件监听模式的优势：在很多应用场景中，通知中附带的 <其他信息> 是必不可少的，事件Event则对这些 <信息> 进行了封装，使它本身拥有了多态的特性。每个事件对象就可以包含不同的信息。但各个 `观察者` 提供给 `主题` 的接口仍然是统一的 ：onNotify(entity, event)。【注-1】

责任链一章中曾谈到，AWT1.0的事件处理模型是基于责任链的，这种模型不适用与复杂的系统，因此在AWT1.1及以后的版本中，时间处理模型均为基于观察者模式的委派事件模型（Delegation Event Model 或 DEM）。
在DEM模型里，主题（Subject）角色负责发布（publish）事件，而观察者角色想特定的主题订阅（subscribe）他所感兴趣的事件。当一个具体主题产生一个事件时，他就会通知所有感兴趣的订阅者。
使用这种发布-订阅机制的基本设计目标是提供一种将发布者与订阅者松散地耦合在一起的联系方式，以及一种能够动态地登记、取消向一个发布者的订阅请求的办法。显然，实现这一构思的技巧是设计抽象接口，并把抽象层和具体层分开。这在观察者模式里可以清楚地看到。
使用DEM的用于，发布者叫做事件源（event source），儿订阅者叫做事件监听器（event listener）。在Java里边,事件由类代表,时间的发布是通过调用成员方法做到的。 【注-2】



## 参考资料


* 【注-1】[监听模式和观察者模式的区别](https://juejin.im/post/5aee749bf265da0b71562ac1)
* 【注-2】[《Java与模式》--阎宏](https://book.douban.com/subject/1214074/)
