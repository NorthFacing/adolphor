---
layout:     post
title:      《Effective Java —— Joshua Bloch》读书笔记
date:       2016-09-20 10:47:57 +0800
postId:     2016-09-20-10-47-57
categories: [blog]
tags:       [Java, 读书笔记]
geneMenu:   true
excerpt:    《Effective Java —— Joshua Bloch》读书笔记
---

## 第1章 引言
虽然本书中的规则不会百分百的适用于任何时刻和任何场合，但他们体现了绝大多数啊
情况下的最佳程序设计实践。你不应该盲目遵从这些规则，但也应该只在偶尔情况下，
有了充分的理由之后才去打破这些规则。

## 第2章 创建和销毁对象

* 何时以及如何创建对象
* 何时以及如何避免创建对象
* 如何确保他们能够适时的销毁
* 如何管理对象销毁之前必须进行的各项清理动作

### 第1条：考虑用静态工厂方法代替构造器 {#tip01}

静态工厂方法与构造器相比有三大优势：

* 它们有名称
    - 这样在相同参数的情况下也能构造不同的实例出来
* 不必在每次调用它们的时候都创建一个新对象
    - 这个应该是使用静态工厂方法的最主要的原因和情景
* 它们可以返回原返回类型的任何子类型的对象，可以要求客户端使用通过接口来引用被返回的对象
    - （TODO：暂时不及理解什么意思）
    - 参考 [第4条](#tip04) 和 [第52条](#tip52)
    - 静态工厂返回的对象所属的类，在编写包含该静态工厂方法的类时可以不必存在，这种灵活的静态工厂方法
    构成了服务提供者框架（Service Provider Framework）的基础。

静态工厂方法的缺点：

* 类如果不含有公有的或者受保护的构造器，就不能被子类化    
* 他们与其他的静态方法，实际上没有任何区别
    - 这样的话就不像构造器那样容易被找到，一般使用如下的命名方式来区分别的静态方法
        - valueOf
        - of
        - getInstance
        - newInstance
        - getType
        - newType


### 第2条：遇到多个构造器参数时要考虑用构建器 {#tip02}

    如果有多个可选参数，那么使用构建器模式是最好的处理方式。
    

如果有多个参数，而且有些参数必填，有些参数可选，在编写构造器的时候有如下几种方式：

* JavaBeans模式
    - 使用默认的无参构造器，其余的参数通过set方法设置
* 使用重叠构造器模式
    - 多个构造器每个构造器多一个参数
* Builder构建器模式
    - 创建一个内部类Builder，作为构造器的参数

构建器模式范例代码：

[NutritionFacts.java](https://github.com/NorthFacing/adolphor/blob/gh-pages/src/main/java/Y2016/M09/D20_effectiv_java/tip02/NutritionFacts.java)


### 第3条：用私有构造器或者枚举类型强化Singleton属性 {#tip03}

    如果确定要使用单利模式，那么使用单个元素的枚举类型是最好的处理方式，虽然这种方法还没有被广泛使用。
    
单例模式有如下几种方法：

* final修饰的公有域
    - 最简单便捷的方法，需要考虑反射、序列化的问题
* 静态工厂方法
    - 如果使用懒加载需要保证线程安全，同样需要考虑反射、序列化的问题
* 枚举类型
    - 最优方法，代码简洁，由虚拟机提供序列化机制，绝对防止反射等方法导致的多次实例化。简洁。高效、线程安全，真的可以说是最佳单例写法。 

范例代码：     

[Elvis01.java](https://github.com/NorthFacing/adolphor/blob/gh-pages/src/main/java/Y2016/M09/D20_effectiv_java/tip03/Elvis01.java)  
[Elvis02.java](https://github.com/NorthFacing/adolphor/blob/gh-pages/src/main/java/Y2016/M09/D20_effectiv_java/tip03/Elvis02.java)  
[Elvis03.java](https://github.com/NorthFacing/adolphor/blob/gh-pages/src/main/java/Y2016/M09/D20_effectiv_java/tip03/Elvis03.java)


### 第4条：通过私有构造器强化不可实例化的能力 {#tip04}
* 对于只包含静态常亮和静态方法的类，比如工具类，是不需要提供实例化的功能的。
但因为所有的类都会提供一个默认的无参构造器，那么它就会有实例化的能力。
所以可以写一个私有的无参构造器来声明此类不能被实例化。

### 第5条：避免创建不必要的对象 {#tip05}

* 如果对象是不可变对象，那么可以一直被重复使用
* 如果对象是可变对象，那么可以将某些不变的属性设置为static属性以供复用
* 在牵扯到数据计算时，使用基本数据类型而不是装箱基本类型，可以避免无意识的自动装箱，提高性能
* 于此相对的是 [第39条](#tip39) 有关“保护性拷贝”的内容，必要时如果没有实施保护性拷贝，将会导致潜在的错误和安全漏洞；
而不必要的创建对象只会影响程序的风格和性能。

### 第6条：消除过期的对象引用 {#tip06}

* 清空对象的引用是为了防止内存泄露
* “清空对象引用应该是一种例外，而不是一种行为规范”，也就是说，不是每个对象都需要显示得清空引用
* “只要类是自己管理内存，就应该警惕内存泄露问题”
* 内存泄露的另一个常见来源是缓存，使用WeakHashMap来解决
* 内存泄露的第三个常见来源是监听器和其他回调，解决方法是只保存他们的弱引用

内存泄露和解决方法范例代码：
[Stack.java](https://github.com/NorthFacing/adolphor/blob/gh-pages/src/main/java/Y2016/M09/D20_effectiv_java/tip06/Stack.java)

### 第7条：避免使用终结方法 {#tip07}

* 反正不要使用 `finalizer` 就行了~

## 第3章 对于所有对象都通用的方法

主要的方法有：

* equals
* hashCode
* toString
* clone
* finalize

### 第8条：覆盖equals时请遵守通用约定 {#tip08}

在不覆盖 `equels` 方法的情况下，类的每个实例都只与它自身相等。如果满足了以下任何一个条件，
这就是所期望的结果：

* 类的每个实例本质上都是唯一的
* 不需要关心类是否提供了"逻辑相等"的测试功能
* 超类已经覆盖了equals，从超类继承过来的行为对于子类也合适，
* 类是私有的或是包级私有的，可以确定他的euqals方法永远不会被调用（此时可以覆写一个抛出异常的equals方法）
git
在覆写的时候要遵守它的通用约定：

* 自反性
    - x.equals(x) => true
* 对称性
    - x.equals(y) <==> y.equals(x)
* 传递性
    - x.equals(y), y.equals(z) => x.equals(z)
* 一致性
    - 多次调用返回的结果相同，不会因为调用次数不同出现不同的结果

实现高质量的equals方法：

* 使用"=="操作符检查"参数是否为这个对象的引用"，也就是比较是否是同一个实例对象
* 使用instanceof操作符检查"参数是否为正确的类型"，如果不是同一个类型，肯定为false
* 把参数转换为正确的类型
* 对于该类中的每个"关键(significant)"域，检查参数中的域是否域该对象中对应的域相匹配
    - 基本数据类型使用 "=="
    - 对象引用域，递归调用equals方法
    - float域，使用 Float.compare 方法
    - double域，使用 Double.compare 方法

覆写 equals 方法范例代码：
[User.java](https://github.com/NorthFacing/adolphor/blob/gh-pages/src/main/java/Y2016/M09/D20_effectiv_java/tip08/User.java)

### 第9条：覆盖equals时总要覆盖hashCode {#tip09}

### 第10条：始终要覆盖toString {#tip10}

### 第11条：谨慎地覆盖clone {#tip11}

### 第12条：考虑实现Comparable接口 {#tip12}

## 第4章 类和接口 

### 第13条：使类和成员的可访问性最小化 {#tip13}

### 第14条：在公有类中使用访问方法而非公有域 {#tip14}

### 第15条：使可变性最小化 {#tip15}

### 第16条：复合优先于继承 {#tip16}

### 第17条：要么为继承而设计，并提供文档说明，要么就禁止继承 {#tip17}

### 第18条：接口优于抽象类 {#tip18}

### 第19条：接口只用于定义类型 {#tip19}

### 第20条：类层次优于标签类 {#tip20}

### 第21条：用函数对象表示策略 {#tip21}

### 第22条：优先考虑静态成员类 {#tip22}

## 第5章 泛型

### 第23条：请不要在新代码中使用原生态类型 {#tip23}

### 第24条：消除非受检警告 {#tip24}

### 第25条：列表优先于数组 {#tip25}

### 第26条：优先考虑泛型 {#tip26}

### 第27条：优先考虑泛型方法 {#tip27}

### 第28条：利用有限制通配符来提升API的灵活性 {#tip28}

### 第29条：优先考虑类型安全的异构容器 {#tip29}

## 第6章 枚举和注解

### 第30条：用enum代替int常量 {#tip30}

### 第31条：用实例域代替序数 {#tip31}

### 第32条：用EnumSet代替位域 {#tip32}

### 第33条：用EnumMap代替序数索引 {#tip33}

### 第34条：用接口模拟可伸缩的枚举 {#tip34}

### 第35条：注解优先于命名模式 {#tip35}

### 第36条：坚持使用Override注解 {#tip36}

### 第36条：使用标记接口定义类型 {#tip37}

## 第7章 方法

### 第38条：检查参数的有效性 {#tip38}

### 第39条：必要时进行保护性拷贝 {#tip39}

### 第40条：谨慎设计方法签名 {#tip40}

### 第41条：慎用重载 {#tip41}

### 第42条：慎用可变参数 {#tip42}

### 第43条：返回零长度的数组或者集合，而不是null {#tip43}

### 第44条：为所有导出的API元素编写文档注释 {#tip44}

## 第8章 通用程序设计

### 第45条：将局部变量的作用域最小化 {#tip45}

### 第46条：for-each循环优先于传统的for循环 {#tip46}

### 第47条：了解和使用类库 {#tip47}

### 第48条：如果需要精确的答案，请避免使用float和double {#tip48}

### 第49条：基本类型优先于装箱基本类型 {#tip49}

### 第50条：如果其他类型更适合，则尽量避免使用字符串 {#tip50}

### 第51条：当心字符串连接的性能 {#tip51}

### 第52条：通过接口引用对象 {#tip52}

### 第53条：接口优先于反射机制 {#tip53}

### 第54条：谨慎地使用本地方法 {#tip54}

### 第55条：谨慎地进行优化 {#tip55}

### 第56条：遵守普遍接受的命名惯例 {#tip56}

## 第9章 异常

### 第57条：只针对异常的情况才使用异常 {#tip57}

### 第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常 {#tip58}

### 第59条：避免不必要地使用受检的异常 {#tip59}

### 第60条：优先使用标准的异常 {#tip60}

### 第61条：抛出与抽象相对应的异常 {#tip61}

### 第62条：每个方法抛出的异常都要有文档 {#tip62}

### 第63条：在细节消息中包含能捕获失败的信息 {#tip63}

### 第64条：努力使失败保持原子性 {#tip64}

### 第65条：不要忽略异常 {#tip65}

## 第10章 并发

### 第66条：同步访问共享的可变数据

### 第66条：同步访问共享的可变数据

### 第68条：executor和task优先于线程

### 第69条：并发工具优先于wait和notify

### 第70条：线程安全性的文档化

### 第71条：慎用延迟初始化

### 第72条：不要依赖于线程调度器

### 第73条：避免使用线程组

## 第11章 序列化

### 第74条：谨慎地实现Serializable接口

### 第75条：考虑使用自定义的序列化形式

### 第76条：保护性地编写readObject方法

### 第77条：对于实例控制，枚举类型优先于readResolve

### 第78条：考虑用序列化代理代替序列化实例

## 参考资料

* [test](test.html)

{% highlight java %}
{% endhighlight %}
